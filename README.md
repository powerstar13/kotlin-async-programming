# 코틀린 비동기 프로그래밍

## Thread

1. 가장 기본이 되는 비동기 처리 방식이다.
2. 스레드는 `Runnable` 인터페이스를 사용해 비동기 동작을 수행한다.
    1. 스레드가 1개인 경우 **싱글 스레드(Single Thread)**라고 부르고, 하나 이상 존재하는 경우 **멀티 스레드(Multi Thread)**라고 부름
3. 멀티 스레드를 사용하면 애플리케이션에서 여러 개의 작업을 동시에 할 수 있다.
4. 멀티 스레드를 사용하면 스케줄링 알고리즘에 의해 스레드가 전환되면서 작업을 처리하는데 이를 `컨텍스트 스위칭`이라 한다.
5. 하나의 `프로세스(Process)`에는 최소한 하나 이상의 스레드가 존재하고, 프로세스 내의 스레드들은 동일한 메모리를 공유한다.
6. **스레드는 프로세스를 생성하는 것보다 가볍다.**
7. 하지만 스레드가 무한정 많아지면 메모리 사용량이 높아져서 `OOME(OutOfMemoryError)`가 발생할 수 있고, 높은 동시 처리량을 요구하는 시스템에서는 스레드를 생성하면서 발생하는 대기 시간 때문에 응답 지연이 발생한다.
    1. 이런 문제를 해결하기 위해선 `스레드 풀(Thread Pool)`을 사용해야 한다.
    2. 직접 만드는 것보다 검증된 라이브러리를 사용해야 한다.
        1. `java.util.concurrent` 패키지의 ExecutorService를 사용하면 쉽고 안전하게 스레드 풀을 사용할 수 있다.
8. ExecutorService
    1. 스레드 풀을 사용하면 애플리케이션 내에서 사용할 총 **스레드 수를 제한할 수 있고**, 기존에 생성된 **스레드를 재사용하므로 빠른 응답이 가능**

## Future

1. `퓨처(Future)`는 비동기 작업에 대한 결과를 얻고 싶은 경우에 사용된다.
    1. 예를 들어 수행 시간이 오래 걸리는 작업이나, 작업에 대한 결과를 기다리면서 다른 작업을 병행해서 수행하고 싶은 경우에 유용함
2. 스레드는 Runnable을 사용해 비동기 처리를 하지만, 퓨처를 사용해 처리 결과를 얻기 위해선 `Callable`을 사용한다.
3. 퓨처를 사용하면 비동기 작업을 쉽게 구현할 수 있지만 몇 가지 단점을 가지고 있다.
    - 먼저 `get` 함수는 비동기 작업의 처리가 완료될 때까지 다음 코드로 넘어가지 않고 무한정 대기하거나 지정해둔 타임아웃 시간까지 블로킹됨
    - 또한 퓨처를 사용하면 동시에 실행되는 한 개 이상의 비동기 작업에 대한 결과를 하나로 조합하여 처리하거나 수동으로 완료 처리(completion)할 수 있는 방법을 지원하지 않음

## Completable Future

1. JDK8부터 퓨처의 단점을 극복하기 위해 `컴플리터블 퓨처(Completable Future)`를 제공한다.
    - `thenApplyAsync`: 논블로킹으로 동작하고 뒤에 Async가 붙은 함수들은 supplyAsync와 별도의 스레드 풀을 지정할 수 있다.
    - `isDone`: 컴플리터블 퓨처가 수행 중인 비동기 작업이 완료된 상태인지를 체크한다.
        - 취소상태를 나타내는 `isCancelled` 그리고 비동기 작업 도중에 에러가 발생한 상태를 나타내는 `isCompletedExceptionally`도 제공
2. CompletableFuture를 쓰더라도 get 함수를 그대로 사용한다면 블로킹 코드가 된다.
3. 컴플리터블 퓨처가 만능 해결사는 아니지만, 대다수의 비동기 처리 시나리오에서 유용하게 사용할 수 있다.
   1. **예를 들면 우리가 개발한 서버에서 외부의 여러 API 서버를 호출하여 응답을 받아서 결과를 결합하고 처리해야 하는 시나리오라면 컴플리터블 퓨처는 매우 유용할 수 있음**

## 옵저버 패턴

1. `옵저버 패턴(Observer Pattern)`이란?
   1. GoF가 소개한 디자인 패턴 중 하나로, 관찰 대상이 되는 객체가 변경되면 대상 객체를 관찰하고 있는 `옵저버(Observer)`에게 변경사항을 `통지(notify)`하는 디자인 패턴을 말한다.
   2. 옵저버 패턴을 사용하면 객체 간의 상호작용을 쉽게 하고, 효과적으로 데이터를 전달할 수 있다.
2. 옵저버 패턴의 구조
   1. 옵저버 패턴은 관찰 대상인 `서브젝트(Subject)`와 Subject를 관찰하는 `옵저버(Observer)`로 이뤄져 있다.
   - 하나의 서브젝트에는 1개 또는 여러 개의 옵저버를 등록할 수 있다.
   - 서브젝트의 상태가 변경되면 자신을 관찰하는 옵저버들에게 변경사항을 통지한다.
   - 서브젝트로 변경사항을 통지받은 옵저버는 부가적인 처리를 한다.
3. 옵저버 패턴의 장점
   - 옵저버 패턴을 사용하지 않았다면 일정 간격으로 완성됐는지 확인하는 처리가 있어야 함
      - 간격이 너무 짧으면 변경된 상태를 빠르게 확인할 수 있지만, 매번 불필요한 호출이 발생하므로 성능상 문제가 발생할 수 있음
      - 또한 간격이 너무 길면 변경된 상태를 즉시 확인할 수 없으므로 실시간성이 떨어질 수 있다.
   - **옵저버 패턴은 관찰자인 옵저버가 서브젝트의 변화를 신경 쓰지 않고, 상태 변경의 주체인 서브젝트가 변경사항을 옵저버에게 알려줌으로써 앞서 언급한 문제를 해결할 수 있다.**
   - 옵저버 패턴은 데이터를 제공하는 측에서 데이터를 소비하는 측에 통지하는 `푸시(Push-Based) 방식`이다.
4. 옵저버 패턴에서 서브젝트와 옵저버는 관심사에 따라 역할과 책임이 분리되어 있다.
   1. 서브젝트는 옵저버가 어떤 작업을 하는지 옵저버의 상태가 어떤지에 대해 관심을 가질 필요가 없다.
   2. 오직 변경 사항을 통지하는 역할만 수행하고, 하나 혹은 다수의 옵저버는 각각 맡은 작업을 스스로 하기 때문에 옵저버가 하는 일이 서브젝트에 영향을 끼치지 않고, 옵저버는 단순한 데이터의 소비자로서 존재하게 된다.

