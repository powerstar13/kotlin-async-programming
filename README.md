# 코틀린 비동기 프로그래밍

## Thread

1. 가장 기본이 되는 비동기 처리 방식이다.
2. 스레드는 `Runnable` 인터페이스를 사용해 비동기 동작을 수행한다.
    1. 스레드가 1개인 경우 **싱글 스레드(Single Thread)**라고 부르고, 하나 이상 존재하는 경우 **멀티 스레드(Multi Thread)**라고 부름
3. 멀티 스레드를 사용하면 애플리케이션에서 여러 개의 작업을 동시에 할 수 있다.
4. 멀티 스레드를 사용하면 스케줄링 알고리즘에 의해 스레드가 전환되면서 작업을 처리하는데 이를 `컨텍스트 스위칭`이라 한다.
5. 하나의 `프로세스(Process)`에는 최소한 하나 이상의 스레드가 존재하고, 프로세스 내의 스레드들은 동일한 메모리를 공유한다.
6. **스레드는 프로세스를 생성하는 것보다 가볍다.**
7. 하지만 스레드가 무한정 많아지면 메모리 사용량이 높아져서 `OOME(OutOfMemoryError)`가 발생할 수 있고, 높은 동시 처리량을 요구하는 시스템에서는 스레드를 생성하면서 발생하는 대기 시간 때문에 응답 지연이 발생한다.
    1. 이런 문제를 해결하기 위해선 `스레드 풀(Thread Pool)`을 사용해야 한다.
    2. 직접 만드는 것보다 검증된 라이브러리를 사용해야 한다.
        1. `java.util.concurrent` 패키지의 ExecutorService를 사용하면 쉽고 안전하게 스레드 풀을 사용할 수 있다.
8. ExecutorService
    1. 스레드 풀을 사용하면 애플리케이션 내에서 사용할 총 **스레드 수를 제한할 수 있고**, 기존에 생성된 **스레드를 재사용하므로 빠른 응답이 가능**

## Future

1. `퓨처(Future)`는 비동기 작업에 대한 결과를 얻고 싶은 경우에 사용된다.
    1. 예를 들어 수행 시간이 오래 걸리는 작업이나, 작업에 대한 결과를 기다리면서 다른 작업을 병행해서 수행하고 싶은 경우에 유용함
2. 스레드는 Runnable을 사용해 비동기 처리를 하지만, 퓨처를 사용해 처리 결과를 얻기 위해선 `Callable`을 사용한다.
3. 퓨처를 사용하면 비동기 작업을 쉽게 구현할 수 있지만 몇 가지 단점을 가지고 있다.
    - 먼저 `get` 함수는 비동기 작업의 처리가 완료될 때까지 다음 코드로 넘어가지 않고 무한정 대기하거나 지정해둔 타임아웃 시간까지 블로킹됨
    - 또한 퓨처를 사용하면 동시에 실행되는 한 개 이상의 비동기 작업에 대한 결과를 하나로 조합하여 처리하거나 수동으로 완료 처리(completion)할 수 있는 방법을 지원하지 않음

## Completable Future

1. JDK8부터 퓨처의 단점을 극복하기 위해 `컴플리터블 퓨처(Completable Future)`를 제공한다.
    - `thenApplyAsync`: 논블로킹으로 동작하고 뒤에 Async가 붙은 함수들은 supplyAsync와 별도의 스레드 풀을 지정할 수 있다.
    - `isDone`: 컴플리터블 퓨처가 수행 중인 비동기 작업이 완료된 상태인지를 체크한다.
        - 취소상태를 나타내는 `isCancelled` 그리고 비동기 작업 도중에 에러가 발생한 상태를 나타내는 `isCompletedExceptionally`도 제공
2. CompletableFuture를 쓰더라도 get 함수를 그대로 사용한다면 블로킹 코드가 된다.
3. 컴플리터블 퓨처가 만능 해결사는 아니지만, 대다수의 비동기 처리 시나리오에서 유용하게 사용할 수 있다.
   1. **예를 들면 우리가 개발한 서버에서 외부의 여러 API 서버를 호출하여 응답을 받아서 결과를 결합하고 처리해야 하는 시나리오라면 컴플리터블 퓨처는 매우 유용할 수 있음**
